{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamReader = exports.EndOfStreamError = void 0;\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\nconst Deferred_1 = require(\"./Deferred\");\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\nObject.defineProperty(exports, \"EndOfStreamError\", {\n  enumerable: true,\n  get: function () {\n    return EndOfFileStream_2.EndOfStreamError;\n  }\n});\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\nclass StreamReader {\n  constructor(s) {\n    this.s = s;\n    /**\r\n     * Deferred used for postponed read request (as not data is yet available to read)\r\n     */\n    this.deferred = null;\n    this.endOfStream = false;\n    /**\r\n     * Store peeked data\r\n     * @type {Array}\r\n     */\n    this.peekQueue = [];\n    if (!s.read || !s.once) {\n      throw new Error('Expected an instance of stream.Readable');\n    }\n    this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n    this.s.once('error', err => this.reject(err));\n    this.s.once('close', () => this.reject(new Error('Stream closed')));\n  }\n  /**\r\n   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\r\n   * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset - Offset target\r\n   * @param length - Number of bytes to read\r\n   * @returns Number of bytes peeked\r\n   */\n  async peek(uint8Array, offset, length) {\n    const bytesRead = await this.read(uint8Array, offset, length);\n    this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\n    return bytesRead;\n  }\n  /**\r\n   * Read chunk from stream\r\n   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset - Offset target\r\n   * @param length - Number of bytes to read\r\n   * @returns Number of bytes read\r\n   */\n  async read(buffer, offset, length) {\n    if (length === 0) {\n      return 0;\n    }\n    if (this.peekQueue.length === 0 && this.endOfStream) {\n      throw new EndOfFileStream_1.EndOfStreamError();\n    }\n    let remaining = length;\n    let bytesRead = 0;\n    // consume peeked data first\n    while (this.peekQueue.length > 0 && remaining > 0) {\n      const peekData = this.peekQueue.pop(); // Front of queue\n      if (!peekData) throw new Error('peekData should be defined');\n      const lenCopy = Math.min(peekData.length, remaining);\n      buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\n      bytesRead += lenCopy;\n      remaining -= lenCopy;\n      if (lenCopy < peekData.length) {\n        // remainder back to queue\n        this.peekQueue.push(peekData.subarray(lenCopy));\n      }\n    }\n    // continue reading from stream if required\n    while (remaining > 0 && !this.endOfStream) {\n      const reqLen = Math.min(remaining, maxStreamReadSize);\n      const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\n      bytesRead += chunkLen;\n      if (chunkLen < reqLen) break;\n      remaining -= chunkLen;\n    }\n    return bytesRead;\n  }\n  /**\r\n   * Read chunk from stream\r\n   * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset Offset target\r\n   * @param length Number of bytes to read\r\n   * @returns Number of bytes read\r\n   */\n  async readFromStream(buffer, offset, length) {\n    const readBuffer = this.s.read(length);\n    if (readBuffer) {\n      buffer.set(readBuffer, offset);\n      return readBuffer.length;\n    } else {\n      const request = {\n        buffer,\n        offset,\n        length,\n        deferred: new Deferred_1.Deferred()\n      };\n      this.deferred = request.deferred;\n      this.s.once('readable', () => {\n        this.readDeferred(request);\n      });\n      return request.deferred.promise;\n    }\n  }\n  /**\r\n   * Process deferred read request\r\n   * @param request Deferred read request\r\n   */\n  readDeferred(request) {\n    const readBuffer = this.s.read(request.length);\n    if (readBuffer) {\n      request.buffer.set(readBuffer, request.offset);\n      request.deferred.resolve(readBuffer.length);\n      this.deferred = null;\n    } else {\n      this.s.once('readable', () => {\n        this.readDeferred(request);\n      });\n    }\n  }\n  reject(err) {\n    this.endOfStream = true;\n    if (this.deferred) {\n      this.deferred.reject(err);\n      this.deferred = null;\n    }\n  }\n}\nexports.StreamReader = StreamReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","StreamReader","EndOfStreamError","EndOfFileStream_1","require","Deferred_1","EndOfFileStream_2","enumerable","get","maxStreamReadSize","constructor","s","deferred","endOfStream","peekQueue","read","once","Error","reject","err","peek","uint8Array","offset","length","bytesRead","push","subarray","buffer","remaining","peekData","pop","lenCopy","Math","min","set","reqLen","chunkLen","readFromStream","readBuffer","request","Deferred","readDeferred","promise","resolve"],"sources":["/Users/nidhi/Desktop/cve-analysis-app/node_modules/peek-readable/lib/StreamReader.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StreamReader = exports.EndOfStreamError = void 0;\r\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\r\nconst Deferred_1 = require(\"./Deferred\");\r\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\r\nObject.defineProperty(exports, \"EndOfStreamError\", { enumerable: true, get: function () { return EndOfFileStream_2.EndOfStreamError; } });\r\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\r\nclass StreamReader {\r\n    constructor(s) {\r\n        this.s = s;\r\n        /**\r\n         * Deferred used for postponed read request (as not data is yet available to read)\r\n         */\r\n        this.deferred = null;\r\n        this.endOfStream = false;\r\n        /**\r\n         * Store peeked data\r\n         * @type {Array}\r\n         */\r\n        this.peekQueue = [];\r\n        if (!s.read || !s.once) {\r\n            throw new Error('Expected an instance of stream.Readable');\r\n        }\r\n        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\r\n        this.s.once('error', err => this.reject(err));\r\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\r\n    }\r\n    /**\r\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\r\n     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes peeked\r\n     */\r\n    async peek(uint8Array, offset, length) {\r\n        const bytesRead = await this.read(uint8Array, offset, length);\r\n        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\r\n    async read(buffer, offset, length) {\r\n        if (length === 0) {\r\n            return 0;\r\n        }\r\n        if (this.peekQueue.length === 0 && this.endOfStream) {\r\n            throw new EndOfFileStream_1.EndOfStreamError();\r\n        }\r\n        let remaining = length;\r\n        let bytesRead = 0;\r\n        // consume peeked data first\r\n        while (this.peekQueue.length > 0 && remaining > 0) {\r\n            const peekData = this.peekQueue.pop(); // Front of queue\r\n            if (!peekData)\r\n                throw new Error('peekData should be defined');\r\n            const lenCopy = Math.min(peekData.length, remaining);\r\n            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\r\n            bytesRead += lenCopy;\r\n            remaining -= lenCopy;\r\n            if (lenCopy < peekData.length) {\r\n                // remainder back to queue\r\n                this.peekQueue.push(peekData.subarray(lenCopy));\r\n            }\r\n        }\r\n        // continue reading from stream if required\r\n        while (remaining > 0 && !this.endOfStream) {\r\n            const reqLen = Math.min(remaining, maxStreamReadSize);\r\n            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\r\n            bytesRead += chunkLen;\r\n            if (chunkLen < reqLen)\r\n                break;\r\n            remaining -= chunkLen;\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset Offset target\r\n     * @param length Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\r\n    async readFromStream(buffer, offset, length) {\r\n        const readBuffer = this.s.read(length);\r\n        if (readBuffer) {\r\n            buffer.set(readBuffer, offset);\r\n            return readBuffer.length;\r\n        }\r\n        else {\r\n            const request = {\r\n                buffer,\r\n                offset,\r\n                length,\r\n                deferred: new Deferred_1.Deferred()\r\n            };\r\n            this.deferred = request.deferred;\r\n            this.s.once('readable', () => {\r\n                this.readDeferred(request);\r\n            });\r\n            return request.deferred.promise;\r\n        }\r\n    }\r\n    /**\r\n     * Process deferred read request\r\n     * @param request Deferred read request\r\n     */\r\n    readDeferred(request) {\r\n        const readBuffer = this.s.read(request.length);\r\n        if (readBuffer) {\r\n            request.buffer.set(readBuffer, request.offset);\r\n            request.deferred.resolve(readBuffer.length);\r\n            this.deferred = null;\r\n        }\r\n        else {\r\n            this.s.once('readable', () => {\r\n                this.readDeferred(request);\r\n            });\r\n        }\r\n    }\r\n    reject(err) {\r\n        this.endOfStream = true;\r\n        if (this.deferred) {\r\n            this.deferred.reject(err);\r\n            this.deferred = null;\r\n        }\r\n    }\r\n}\r\nexports.StreamReader = StreamReader;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}