{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadStreamTokenizer = void 0;\nconst AbstractTokenizer_1 = require(\"./AbstractTokenizer\");\nconst peek_readable_1 = require(\"peek-readable\");\nconst maxBufferSize = 256000;\nclass ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {\n  constructor(stream, fileInfo) {\n    super(fileInfo);\n    this.streamReader = new peek_readable_1.StreamReader(stream);\n  }\n  /**\r\n   * Get file information, an HTTP-client may implement this doing a HEAD request\r\n   * @return Promise with file information\r\n   */\n  async getFileInfo() {\n    return this.fileInfo;\n  }\n  /**\r\n   * Read buffer from tokenizer\r\n   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\r\n   * @param options - Read behaviour options\r\n   * @returns Promise with number of bytes read\r\n   */\n  async readBuffer(uint8Array, options) {\n    const normOptions = this.normalizeOptions(uint8Array, options);\n    const skipBytes = normOptions.position - this.position;\n    if (skipBytes > 0) {\n      await this.ignore(skipBytes);\n      return this.readBuffer(uint8Array, options);\n    } else if (skipBytes < 0) {\n      throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n    }\n    if (normOptions.length === 0) {\n      return 0;\n    }\n    const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);\n    this.position += bytesRead;\n    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {\n      throw new peek_readable_1.EndOfStreamError();\n    }\n    return bytesRead;\n  }\n  /**\r\n   * Peek (read ahead) buffer from tokenizer\r\n   * @param uint8Array - Uint8Array (or Buffer) to write data to\r\n   * @param options - Read behaviour options\r\n   * @returns Promise with number of bytes peeked\r\n   */\n  async peekBuffer(uint8Array, options) {\n    const normOptions = this.normalizeOptions(uint8Array, options);\n    let bytesRead = 0;\n    if (normOptions.position) {\n      const skipBytes = normOptions.position - this.position;\n      if (skipBytes > 0) {\n        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);\n        bytesRead = await this.peekBuffer(skipBuffer, {\n          mayBeLess: normOptions.mayBeLess\n        });\n        uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);\n        return bytesRead - skipBytes;\n      } else if (skipBytes < 0) {\n        throw new Error('Cannot peek from a negative offset in a stream');\n      }\n    }\n    if (normOptions.length > 0) {\n      try {\n        bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);\n      } catch (err) {\n        if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {\n          return 0;\n        }\n        throw err;\n      }\n      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {\n        throw new peek_readable_1.EndOfStreamError();\n      }\n    }\n    return bytesRead;\n  }\n  async ignore(length) {\n    // debug(`ignore ${this.position}...${this.position + length - 1}`);\n    const bufSize = Math.min(maxBufferSize, length);\n    const buf = new Uint8Array(bufSize);\n    let totBytesRead = 0;\n    while (totBytesRead < length) {\n      const remaining = length - totBytesRead;\n      const bytesRead = await this.readBuffer(buf, {\n        length: Math.min(bufSize, remaining)\n      });\n      if (bytesRead < 0) {\n        return bytesRead;\n      }\n      totBytesRead += bytesRead;\n    }\n    return totBytesRead;\n  }\n}\nexports.ReadStreamTokenizer = ReadStreamTokenizer;","map":{"version":3,"names":["Object","defineProperty","exports","value","ReadStreamTokenizer","AbstractTokenizer_1","require","peek_readable_1","maxBufferSize","AbstractTokenizer","constructor","stream","fileInfo","streamReader","StreamReader","getFileInfo","readBuffer","uint8Array","options","normOptions","normalizeOptions","skipBytes","position","ignore","Error","length","bytesRead","read","offset","mayBeLess","EndOfStreamError","peekBuffer","skipBuffer","Uint8Array","set","subarray","peek","err","bufSize","Math","min","buf","totBytesRead","remaining"],"sources":["/Users/nidhi/Desktop/cve-analysis-app/node_modules/strtok3/lib/ReadStreamTokenizer.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ReadStreamTokenizer = void 0;\r\nconst AbstractTokenizer_1 = require(\"./AbstractTokenizer\");\r\nconst peek_readable_1 = require(\"peek-readable\");\r\nconst maxBufferSize = 256000;\r\nclass ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {\r\n    constructor(stream, fileInfo) {\r\n        super(fileInfo);\r\n        this.streamReader = new peek_readable_1.StreamReader(stream);\r\n    }\r\n    /**\r\n     * Get file information, an HTTP-client may implement this doing a HEAD request\r\n     * @return Promise with file information\r\n     */\r\n    async getFileInfo() {\r\n        return this.fileInfo;\r\n    }\r\n    /**\r\n     * Read buffer from tokenizer\r\n     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes read\r\n     */\r\n    async readBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        const skipBytes = normOptions.position - this.position;\r\n        if (skipBytes > 0) {\r\n            await this.ignore(skipBytes);\r\n            return this.readBuffer(uint8Array, options);\r\n        }\r\n        else if (skipBytes < 0) {\r\n            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\r\n        }\r\n        if (normOptions.length === 0) {\r\n            return 0;\r\n        }\r\n        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);\r\n        this.position += bytesRead;\r\n        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {\r\n            throw new peek_readable_1.EndOfStreamError();\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Peek (read ahead) buffer from tokenizer\r\n     * @param uint8Array - Uint8Array (or Buffer) to write data to\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes peeked\r\n     */\r\n    async peekBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        let bytesRead = 0;\r\n        if (normOptions.position) {\r\n            const skipBytes = normOptions.position - this.position;\r\n            if (skipBytes > 0) {\r\n                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);\r\n                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });\r\n                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);\r\n                return bytesRead - skipBytes;\r\n            }\r\n            else if (skipBytes < 0) {\r\n                throw new Error('Cannot peek from a negative offset in a stream');\r\n            }\r\n        }\r\n        if (normOptions.length > 0) {\r\n            try {\r\n                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);\r\n            }\r\n            catch (err) {\r\n                if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {\r\n                    return 0;\r\n                }\r\n                throw err;\r\n            }\r\n            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {\r\n                throw new peek_readable_1.EndOfStreamError();\r\n            }\r\n        }\r\n        return bytesRead;\r\n    }\r\n    async ignore(length) {\r\n        // debug(`ignore ${this.position}...${this.position + length - 1}`);\r\n        const bufSize = Math.min(maxBufferSize, length);\r\n        const buf = new Uint8Array(bufSize);\r\n        let totBytesRead = 0;\r\n        while (totBytesRead < length) {\r\n            const remaining = length - totBytesRead;\r\n            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });\r\n            if (bytesRead < 0) {\r\n                return bytesRead;\r\n            }\r\n            totBytesRead += bytesRead;\r\n        }\r\n        return totBytesRead;\r\n    }\r\n}\r\nexports.ReadStreamTokenizer = ReadStreamTokenizer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}